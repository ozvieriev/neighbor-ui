"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

angular.module('app.auth', []);
angular.module('app.services', []);
angular.module('app.controllers', []);
angular.module('app.directives', []);
angular.module('app.filters', []);
angular.module('app', ['ui.router', 'app.auth', 'app.services', 'app.controllers', 'app.directives', 'app.filters']).run(function ($trace, $transitions, $auth) {
  $trace.enable('TRANSITION');
  $transitions.onBefore({
    to: '**'
  }, function (transitions) {// if (transitions.to().isProtected && !$auth.isAuthenticated())
    //     return transitions.router.stateService.target('user/sign-in');
  });
}).config(function ($stateProvider, $urlRouterProvider) {
  // $locationProvider.html5Mode({
  //     enabled: true,
  //     requireBase: false
  // });
  $urlRouterProvider.otherwise('/en/index');
  $stateProvider.state('app', {
    url: '/:locale',
    //templateUrl: 'index.html',
    restricted: false,
    abstract: true,
    views: {
      header: {
        templateUrl: 'partial/header.html'
      },
      footer: {
        templateUrl: 'partial/footer.html'
      },
      content: {
        controller: 'appController'
      }
    }
  });

  var _state = function _state(json) {
    json.name = json.name || json.url;
    json.params = json.params || {};
    json.templateUrl = json.templateUrl || "views/".concat(json.url, ".html");
    json.isProtected = !!json.isProtected;
    var state = {
      parent: 'app',
      url: "/".concat(json.url),
      params: json.params,
      templateUrl: json.templateUrl,
      isProtected: json.isProtected
    };
    if (json.controller) state.controller = "".concat(json.controller, "Controller");
    $stateProvider.state(json.name, state);
  };

  _state({
    url: 'about'
  });

  _state({
    url: 'contact-us'
  });

  _state({
    url: 'disclaimer'
  });

  _state({
    url: 'index',
    controller: 'index'
  });

  _state({
    url: 'privacy'
  });

  _state({
    url: 'resources'
  }); // _state({
  //     url: 'account', controller: 'account', templateUrl: 'views/account/index.html',
  //     params: { accountId: null }, isProtected: true
  // });
  // _state({
  //     url: 'account/email-is-empty', controller: 'accountEmailIsEmpty',
  //     params: { email: null }, isProtected: true
  // });
  // _state({
  //     url: 'account/not-found', controller: 'accountNotFound',
  //     params: { email: null }, isProtected: true
  // });
  // _state({ url: 'brand/not-supported', controller: 'brandNotSupported' });
  // _state({ url: 'ticket/not-found', controller: 'ticketNotFound' });
  // _state({ url: 'ticket/requester-email-is-empty', controller: 'ticketRequesterEmailIsEmpty' });
  // _state({ url: 'user/sign-in', controller: 'userSignIn' });
  // _state({ url: 'zat/client-not-found', controller: 'zatClientNotFound' });

}); //https://github.com/modularcode/modular-admin-angularjs/blob/master/src/_main.js

angular.module('app').config(['$httpProvider', function ($httpProvider) {
  $httpProvider.interceptors.push(['$q', function ($q) {
    var interceptor = {};

    interceptor.response = function (response) {
      var config = response.config || {};
      if (config.asJson === true) return response.data;
      return response;
    };

    return interceptor;
  }]);
}]);
angular.module('app.auth').factory('$auth', ['$q', '$state', '$injector', '$authStorage', function ($q, $state, $injector, $authStorage) {
  var _apiHeaders = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };
  var service = {};
  return service;
}]);
angular.module('app.auth').factory('$authBuffer', ['$injector', function ($injector) {
  /** Holds all the requests, so they can be re-requested in future. */
  var _buffer = [];
  /** Service initialized later because of circular dependency problem. */

  var $http;

  var _retryHttpRequest = function _retryHttpRequest(config, deferred) {
    var _success = function _success(response) {
      deferred.resolve(response);
    };

    var _error = function _error(response) {
      deferred.reject(response);
    };

    $http = $http || $injector.get('$http');
    $http(config).then(_success, _error);
  };

  var service = {};
  /**
  * Appends HTTP request configuration object with deferred response attached to buffer.
  */

  service.append = function (config, deferred) {
    _buffer.push({
      config: config,
      deferred: deferred
    });
  };
  /**
  * Abandon or reject (if reason provided) all the buffered requests.
  */


  service.rejectAll = function (reason) {
    if (reason) {
      for (var index = 0; index < _buffer.length; ++index) {
        _buffer[index].deferred.reject(reason);
      }
    }

    _buffer = [];
  };
  /**
   * Retries all the buffered requests clears the buffer.
   */


  service.retryAll = function (updater) {
    for (var index = 0; index < _buffer.length; ++index) {
      _retryHttpRequest(updater(_buffer[index].config), _buffer[index].deferred);
    }

    _buffer = [];
  };

  return service;
}]);
angular.module('app.auth').config(['$httpProvider', function ($httpProvider) {
  $httpProvider.interceptors.push(['$q', '$auth', '$authInterceptor', '$authBuffer', function ($q, $auth, $authInterceptor, $authBuffer) {
    var interceptor = {};

    interceptor.request = function (config) {
      config.headers = config.headers || {}; //   if ($auth.isAuthenticated())
      //       config.headers.Authorization = 'bearer ' + $auth.getAccessToken();

      return config;
    };

    interceptor.responseError = function (rejection) {
      var config = rejection.config || {};

      switch (rejection.status) {
        case 401:
          var deferred = $q.defer();
          $authBuffer.append(config, deferred);
          $auth.refreshToken().then($authInterceptor.loginConfirmed, $auth.logout);
          return deferred.promise;
      }

      return $q.reject(rejection);
    };

    return interceptor;
  }]);
}]);
angular.module('app.auth').factory('$authInterceptor', ['$authBuffer', function ($authBuffer) {
  var service = {};
  /**
  * Call this function to indicate that authentication was successfull and trigger a
  * retry of all deferred requests.
  * @param data an optional argument to pass on to $broadcast which may be useful for
  * example if you need to pass through details of the user that was logged in
  * @param configUpdater an optional transformation function that can modify the
  * requests that are retried after having logged in.  This can be used for example
  * to add an authentication token.  It must return the request.
  */

  service.loginConfirmed = function (data, configUpdater) {
    var updater = configUpdater || function (config) {
      return config;
    };

    $authBuffer.retryAll(updater);
  };
  /**
   * Call this function to indicate that authentication should not proceed.
   * All deferred requests will be abandoned or rejected (if reason is provided).
   * @param data an optional argument to pass on to $broadcast.
   * @param reason if provided, the requests are rejected; abandoned otherwise.
   */


  service.loginCancelled = function (data, reason) {
    $authBuffer.rejectAll(reason);
  };

  return service;
}]);
angular.module('app.auth').factory('$authStorage', ['$window', function ($window) {
  var _localStorage = {};

  var _getItem = function _getItem(key) {
    var json = _localStorage[key];
    var value = json ? JSON.parse(json) : null;
    _localStorage[key] = json;

    try {
      json = $window.localStorage.getItem(key);
      json && (value = JSON.parse(json));
    } catch (error) {
      console.error(error);
    }

    return value;
  };

  var _setItem = function _setItem(key, value) {
    var json = JSON.stringify(value);
    _localStorage[key] = json;

    try {
      $window.localStorage.setItem(key, json);
    } catch (error) {
      console.error(error);
    }
  };

  var _removeItem = function _removeItem(key) {
    delete _localStorage[key];

    try {
      $window.localStorage.removeItem(key);
    } catch (error) {
      console.error(error);
    }
  };

  var service = {};

  service.getItem = function (brandIso) {
    return _getItem("auth:".concat(brandIso));
  };

  service.setItem = function (brandIso, json) {
    _setItem("auth:".concat(brandIso), json);
  };

  service.removeItem = function (brandIso) {
    _removeItem("auth:".concat(brandIso));
  };

  return service;
}]);
angular.module('app.controllers').controller('appController', ['$scope', '$state', '$stateParams', function ($scope, $state, $stateParams) {}]);
angular.module('app.controllers').controller('indexController', ['$scope', function ($scope) {}]);
angular.module('app.services').factory('$api', ['$http', function factory($http) {
  var service = {};
  return service;
}]);
angular.module('app.services').factory('$form', function () {
  var service = {};

  service.submit = function (entity, form, callback) {
    if (form.$valid !== true) {
      angular.forEach(form, function (value, key) {
        if (_typeof(value) === 'object' && value.hasOwnProperty('$modelValue')) value.$setDirty();
      });
    }

    if (service.isReady(entity, form) === false) return;
    callback(form);
  };

  service.isReady = function (entity, form) {
    if (entity.isBusy === true || form.$valid !== true) return false;
    entity.isBusy = true;
    return true;
  };

  return service;
});
angular.module('app.directives').directive('braille', ['$window', function ($window) {
  var template = ['<ul class="navbar-nav">', '<li class="nav-item active" data-rem="1.0"><a class="nav-link" href="#">A</a></li>', '<li class="nav-item" data-rem="1.2"><a class="nav-link" href="#">A</a></li>', '<li class="nav-item" data-rem="1.5"><a class="nav-link" href="#">A</a></li>', '</ul>'].join('');
  return {
    restrict: 'E',
    replace: true,
    template: template,
    link: function link(scope, element, attrs) {
      var liCollection = element.find('li[data-rem]');
      liCollection.each(function (index, value) {
        var li = angular.element(value);
        var rem = li.attr('data-rem');
        li.css({
          'font-size': "".concat(rem, "rem"),
          'line-height': '1.7rem'
        });
        li.find('a').bind('click', function () {
          liCollection.removeClass('active');
          liCollection.eq(index).addClass('active');
          angular.element('body').css({
            'font-size': "".concat(rem, "rem")
          });
        });
      }); // element.find('a').bind('click', function () {
      //     var index = $(this).index();
      //     debugger
      //     $('body').css({ 'font-size': '1.2rem' });
      // });
    }
  };
}]);
angular.module('app.directives').directive('ngDate', ['$filter', function ($filter) {
  return {
    restrict: 'A',
    scope: {
      date: '=ngDate',
      format: '=ngFormat'
    },
    link: function link(scope, element, attrs) {
      if (!scope.date) return;
      element.addClass('text-muted small');
      var format = scope.format || 'yyyy-MM-dd HH:mm';
      scope.$watch('date', function (newValue, oldValue) {
        if (newValue || newValue != oldValue) element.html("<em>" + $filter('date')(scope.date, format) + "</em>");
      });
    }
  };
}]);