"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

angular.module('app.auth', []);
angular.module('app.services', []);
angular.module('app.controllers', []);
angular.module('app.directives', []);
angular.module('app.filters', []);
angular.module('app', ['ui.router', 'app.auth', 'app.services', 'app.controllers', 'app.directives', 'app.filters']).run(function ($trace, $transitions, $auth) {
  $trace.enable('TRANSITION');
  $transitions.onBefore({
    to: '**'
  }, function (transitions) {
    if (transitions.to().isProtected && !$auth.isAuthenticated()) return transitions.router.stateService.target('user/sign-in');
  });
}).config(function ($stateProvider, $urlRouterProvider) {
  // $locationProvider.html5Mode({
  //     enabled: true,
  //     requireBase: false
  // });
  $urlRouterProvider.otherwise('/en/index');
  $stateProvider.state('app', {
    url: '/:locale',
    //templateUrl: 'index.html',
    restricted: false,
    abstract: true,
    views: {
      sidebar: {
        controller: 'partialSidebarController',
        templateUrl: 'partial/sidebar.html'
      },
      content: {
        controller: 'appController'
      }
    }
  });

  var _state = function _state(json) {
    json.name = json.name || json.url;
    json.params = json.params || {};
    json.templateUrl = json.templateUrl || "views/".concat(json.url, ".html");
    json.isProtected = !!json.isProtected;
    var state = {
      parent: 'app',
      url: "/".concat(json.url),
      params: json.params,
      templateUrl: json.templateUrl,
      controller: "".concat(json.controller, "Controller"),
      isProtected: json.isProtected
    };
    $stateProvider.state(json.name, state);
  };

  _state({
    url: 'index',
    controller: 'index'
  });

  _state({
    url: 'account',
    controller: 'account',
    templateUrl: 'views/account/index.html',
    params: {
      accountId: null
    },
    isProtected: true
  });

  _state({
    url: 'account/email-is-empty',
    controller: 'accountEmailIsEmpty',
    params: {
      email: null
    },
    isProtected: true
  });

  _state({
    url: 'account/not-found',
    controller: 'accountNotFound',
    params: {
      email: null
    },
    isProtected: true
  });

  _state({
    url: 'brand/not-supported',
    controller: 'brandNotSupported'
  });

  _state({
    url: 'ticket/not-found',
    controller: 'ticketNotFound'
  });

  _state({
    url: 'ticket/requester-email-is-empty',
    controller: 'ticketRequesterEmailIsEmpty'
  });

  _state({
    url: 'user/sign-in',
    controller: 'userSignIn'
  });

  _state({
    url: 'zat/client-not-found',
    controller: 'zatClientNotFound'
  });
}); //https://github.com/modularcode/modular-admin-angularjs/blob/master/src/_main.js

angular.module('app').config(['$httpProvider', function ($httpProvider) {
  $httpProvider.interceptors.push(['$q', function ($q) {
    var interceptor = {};

    interceptor.response = function (response) {
      var config = response.config || {};
      if (config.asJson === true) return response.data;
      return response;
    };

    return interceptor;
  }]);
}]);
angular.module('app.auth').factory('$auth', ['$q', '$state', '$injector', '$authStorage', '$brand', function ($q, $state, $injector, $authStorage, $brand) {
  var _apiHeaders = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };
  var service = {};

  var _getItem = function _getItem() {
    var iso = $brand.getIso();
    return $authStorage.getItem(iso);
  };

  service.isAuthenticated = function () {
    if ($brand.isEmpty()) return false;
    return !!_getItem();
  };

  service.getAccessToken = function () {
    var item = _getItem();

    return item ? item.access_token : null;
  };

  service.getRefreshToken = function () {
    var item = _getItem();

    return item ? item.refresh_token : null;
  };

  service.signIn = function (login, password) {
    var $http = $injector.get("$http");
    var data = ['grant_type=password', 'username=' + encodeURIComponent(login), 'password=' + encodeURIComponent(password)];
    data = data.join('&');
    var deferred = $q.defer();

    if ($brand.isEmpty()) {
      deferred.reject({
        error_description: 'Brand is not supported!'
      });
    } else {
      var uri = $brand.getApiUri('api/token');
      $http.post(uri, data, {
        headers: _apiHeaders,
        asJson: true
      }).then(function (json) {
        var iso = $brand.getIso();
        $authStorage.setItem(iso, json);
        deferred.resolve(json);
      }, function (error, status, headers) {
        deferred.reject(error.data);
      });
    }

    return deferred.promise;
  };

  service.refreshToken = function () {
    var $http = $injector.get("$http");
    var data = ['grant_type=refresh_token', 'refresh_token=' + service.getRefreshToken()];
    data = data.join('&');
    var deferred = $q.defer();
    var uri = $brand.getApiUri('api/token');
    $http.post(uri, data, {
      headers: _apiHeaders,
      asJson: true
    }).then(function (json) {
      var iso = $brand.getIso();
      $authStorage.setItem(iso, json);
      deferred.resolve(json);
    }, function (error, status, headers) {
      service.logout();
      deferred.reject(status);
    });
    return deferred.promise;
  };

  service.logout = function () {
    var iso = $brand.getIso();
    $authStorage.removeItem(iso);
    $state.go('user/sign-in');
  };

  return service;
}]);
angular.module('app.auth').factory('$authBuffer', ['$injector', function ($injector) {
  /** Holds all the requests, so they can be re-requested in future. */
  var _buffer = [];
  /** Service initialized later because of circular dependency problem. */

  var $http;

  var _retryHttpRequest = function _retryHttpRequest(config, deferred) {
    var _success = function _success(response) {
      deferred.resolve(response);
    };

    var _error = function _error(response) {
      deferred.reject(response);
    };

    $http = $http || $injector.get('$http');
    $http(config).then(_success, _error);
  };

  var service = {};
  /**
  * Appends HTTP request configuration object with deferred response attached to buffer.
  */

  service.append = function (config, deferred) {
    _buffer.push({
      config: config,
      deferred: deferred
    });
  };
  /**
  * Abandon or reject (if reason provided) all the buffered requests.
  */


  service.rejectAll = function (reason) {
    if (reason) {
      for (var index = 0; index < _buffer.length; ++index) {
        _buffer[index].deferred.reject(reason);
      }
    }

    _buffer = [];
  };
  /**
   * Retries all the buffered requests clears the buffer.
   */


  service.retryAll = function (updater) {
    for (var index = 0; index < _buffer.length; ++index) {
      _retryHttpRequest(updater(_buffer[index].config), _buffer[index].deferred);
    }

    _buffer = [];
  };

  return service;
}]);
angular.module('app.auth').config(['$httpProvider', function ($httpProvider) {
  $httpProvider.interceptors.push(['$q', '$auth', '$authInterceptor', '$authBuffer', function ($q, $auth, $authInterceptor, $authBuffer) {
    var interceptor = {};

    interceptor.request = function (config) {
      config.headers = config.headers || {};
      if ($auth.isAuthenticated()) config.headers.Authorization = 'bearer ' + $auth.getAccessToken();
      return config;
    };

    interceptor.responseError = function (rejection) {
      var config = rejection.config || {};

      switch (rejection.status) {
        case 401:
          var deferred = $q.defer();
          $authBuffer.append(config, deferred);
          $auth.refreshToken().then($authInterceptor.loginConfirmed, $auth.logout);
          return deferred.promise;
      }

      return $q.reject(rejection);
    };

    return interceptor;
  }]);
}]);
angular.module('app.auth').factory('$authInterceptor', ['$authBuffer', function ($authBuffer) {
  var service = {};
  /**
  * Call this function to indicate that authentication was successfull and trigger a
  * retry of all deferred requests.
  * @param data an optional argument to pass on to $broadcast which may be useful for
  * example if you need to pass through details of the user that was logged in
  * @param configUpdater an optional transformation function that can modify the
  * requests that are retried after having logged in.  This can be used for example
  * to add an authentication token.  It must return the request.
  */

  service.loginConfirmed = function (data, configUpdater) {
    var updater = configUpdater || function (config) {
      return config;
    };

    $authBuffer.retryAll(updater);
  };
  /**
   * Call this function to indicate that authentication should not proceed.
   * All deferred requests will be abandoned or rejected (if reason is provided).
   * @param data an optional argument to pass on to $broadcast.
   * @param reason if provided, the requests are rejected; abandoned otherwise.
   */


  service.loginCancelled = function (data, reason) {
    $authBuffer.rejectAll(reason);
  };

  return service;
}]);
angular.module('app.auth').factory('$authStorage', ['$window', function ($window) {
  var _localStorage = {};

  var _getItem = function _getItem(key) {
    var json = _localStorage[key];
    var value = json ? JSON.parse(json) : null;
    _localStorage[key] = json;

    try {
      json = $window.localStorage.getItem(key);
      json && (value = JSON.parse(json));
    } catch (error) {
      console.error(error);
    }

    return value;
  };

  var _setItem = function _setItem(key, value) {
    var json = JSON.stringify(value);
    _localStorage[key] = json;

    try {
      $window.localStorage.setItem(key, json);
    } catch (error) {
      console.error(error);
    }
  };

  var _removeItem = function _removeItem(key) {
    delete _localStorage[key];

    try {
      $window.localStorage.removeItem(key);
    } catch (error) {
      console.error(error);
    }
  };

  var service = {};

  service.getItem = function (brandIso) {
    return _getItem("auth:".concat(brandIso));
  };

  service.setItem = function (brandIso, json) {
    _setItem("auth:".concat(brandIso), json);
  };

  service.removeItem = function (brandIso) {
    _removeItem("auth:".concat(brandIso));
  };

  return service;
}]);
angular.module('app.controllers').controller('appController', ['$scope', '$state', '$stateParams', '$zendeskApi', '$brand', '$auth', function ($scope, $state, $stateParams, $zendeskApi, $brand, $auth) {
  $zendeskApi.init();
  if ($zendeskApi.isEmpty()) return $state.go('zat/client-not-found');
  $zendeskApi.get(['ticket.brand']).then(function (response) {
    $brand.set(response['ticket.brand']);
    if (!$brand.isSupport()) return $state.go('brand/not-supported');
    $scope.$auth = $auth;
    $state.go('account');
  }, function () {
    $state.go('ticket/not-found');
  });
}]);
angular.module('app.controllers').controller('indexController', ['$scope', function ($scope) {}]);
angular.module('app.directives').directive('ngAccountActivated', ['$api', function ($api) {
  return {
    restrict: 'A',
    scope: {
      status: '=ngAccountActivated'
    },
    link: function link(scope, element, attrs) {
      element.addClass('badge');
      var watch = scope.$watch('status', function () {
        element.removeClass('badge-warning').removeClass('badge-success');
        !$api.account.isActivated(scope) && element.addClass('badge-warning').text('not activated');
        $api.account.isActivated(scope) && element.addClass('badge-success').text('activated');
      });
      scope.$on("$destroy", function () {
        watch();
      });
    }
  };
}]);
angular.module('app.directives').directive('ngAccountType', ['$api', function ($api) {
  return {
    restrict: 'A',
    scope: {
      status: '=ngAccountType'
    },
    link: function link(scope, element, attrs) {
      element.addClass('badge');
      var watch = scope.$watch('status', function () {
        element.removeClass('badge-primary').removeClass('badge-info');
        !$api.account.isBusiness(scope) && element.addClass('badge-info').text('b2c');
        $api.account.isBusiness(scope) && element.addClass('badge-primary').text('b2b');
      });
      scope.$on("$destroy", function () {
        watch();
      });
    }
  };
}]);
angular.module('app.directives').directive('ngDate', ['$filter', function ($filter) {
  return {
    restrict: 'A',
    scope: {
      date: '=ngDate',
      format: '=ngFormat'
    },
    link: function link(scope, element, attrs) {
      if (!scope.date) return;
      element.addClass('text-muted small');
      var format = scope.format || 'yyyy-MM-dd HH:mm';
      scope.$watch('date', function (newValue, oldValue) {
        if (newValue || newValue != oldValue) element.html("<em>" + $filter('date')(scope.date, format) + "</em>");
      });
    }
  };
}]);
angular.module('app.directives').directive('ngExternalConnectedAccountStatus', [function () {
  return {
    restrict: 'A',
    link: function link(scope, element, attrs) {
      element.addClass('fas');

      if (attrs.ngExternalConnectedAccountStatus === 'false') {
        element.addClass('fa-user-slash text-danger').attr('title', 'Disconnected');
      } else {
        element.addClass('fa-user text-success').attr('title', 'Connected');
      }
    }
  };
}]);
angular.module('app.directives').directive('ngExternalConnectedAccount', [function () {
  return {
    restrict: 'A',
    link: function link(scope, element, attrs) {
      element.addClass('fab').addClass('fa-' + attrs.ngExternalConnectedAccount);

      switch (attrs.ngExternalConnectedAccount) {
        case 'google':
          element.css({
            color: '#d62d20'
          });
          break;

        case 'facebook':
          element.css({
            color: '#3b5998'
          });
          break;

        case 'microsoft':
          element.css({
            color: '#00a1f1'
          });
          break;
      }
    }
  };
}]);
angular.module('app.directives').directive('ngSidebar', ['$api', function ($api) {
  return {
    restrict: 'A',
    link: function link(scope, element, attrs) {
      var sidebar = element.find('.sidebar:first, .sidebar-content');
      var buttons = element.find('button.navbar-toggler');
      buttons.eq(0).bind('click', function () {
        sidebar.css({
          height: '100%'
        });
      });
      element.find('.btn').bind('click', function () {
        sidebar.css({
          height: '0%'
        });
      });
      buttons.eq(1).bind('click', function () {
        sidebar.css({
          height: '0%'
        });
      });
    }
  };
}]);
angular.module('app.services').factory('$api', ['$http', '$brand', function factory($http, $brand) {
  var service = {};
  var accountStatusEnum = {
    none: 0,
    isActivated: 1 << 0,
    isAnonymous: 1 << 1,
    isBusiness: 1 << 2
  };
  ;
  service.account = {
    isActivated: function isActivated(account) {
      return !!(account.status & accountStatusEnum.isActivated);
    },
    isBusiness: function isBusiness(account) {
      return !!(account.status & accountStatusEnum.isBusiness);
    },
    get: function get(params) {
      var method = 'api/account/';

      if (params.accountId) {
        method += params.accountId;
        delete params.accountId;
      }

      return $http.get($brand.getApiUri(method), {
        asJson: true,
        params: params
      });
    }
  };

  service.account.getSubEmails = function (params) {
    return $http.get($brand.getApiUri("api/account/".concat(params.accountId, "/sub-email")), {
      asJson: true
    });
  };

  service.account.getExternalSessionTokens = function (params) {
    return $http.get($brand.getApiUri("api/account/".concat(params.accountId, "/external/session-token")), {
      asJson: true
    });
  };

  return service;
}]);
angular.module('app.services').factory('$brand', function () {
  var _brands = {
    sodapdf: {
      api: 'https://cp-oauth.sodapdf.com'
    },
    pdfarchitect: {
      api: 'https://cp-oauth.pdfarchitect.org'
    }
  };
  var _brand = null;
  var service = {};

  service.isEmpty = function () {
    return !_brand;
  };

  service.set = function (brand) {
    _brand = brand;
  };

  service.get = function () {
    return _brand;
  };

  service.isSupport = function () {
    var iso = service.getIso(_brand);
    return !!_brands[iso];
  };

  service.getIso = function () {
    return _brand.subdomain;
  };

  service.getApiUri = function (method) {
    var iso = service.getIso();
    var api = _brands[iso].api;
    return "".concat(api, "/").concat(method);
  };

  service.getLogo = function () {
    if (service.isEmpty()) return null;
    return _brand.logo.contentUrl;
  };

  return service;
});
angular.module('app.services').factory('$form', function () {
  var service = {};

  service.submit = function (entity, form, callback) {
    if (form.$valid !== true) {
      angular.forEach(form, function (value, key) {
        if (_typeof(value) === 'object' && value.hasOwnProperty('$modelValue')) value.$setDirty();
      });
    }

    if (service.isReady(entity, form) === false) return;
    callback(form);
  };

  service.isReady = function (entity, form) {
    if (entity.isBusy === true || form.$valid !== true) return false;
    entity.isBusy = true;
    return true;
  };

  return service;
});
angular.module('app.services').factory('$zendeskApi', ['$q', '$http', function factory($q, $http) {
  var _zClient = ZAFClient.init();

  var service = {};

  service.init = function () {
    _zClient && _zClient.invoke('resize', {
      width: '100%',
      height: '640px'
    });
  };

  service.isEmpty = function () {
    return !_zClient;
  };

  service.on = function (key, callback) {
    return _zClient.on(key, callback);
  };

  service.get = function (key) {
    return _zClient.get(key);
  };

  return service;
}]);
angular.module('app.controllers').controller('accountController', ['$scope', '$state', '$zendeskApi', '$api', function ($scope, $state, $zendeskApi, $api) {
  $scope.isLoading = true;
  $scope.model = {
    account: null,
    subEmails: null,
    sessionTokens: null
  };
  $zendeskApi.get(['ticket.requester']).then(function (response) {
    var requester = response['ticket.requester'];
    if (!requester.email) return $state.go('account/email-is-empty');
    $api.account.get({
      email: requester.email
    }).then(function (json) {
      $scope.model.account = json;
    }, function () {
      $state.go('account/not-found', {
        email: requester.email
      });
    });
  }, function () {
    $state.go('ticket/requester-email-is-empty');
  });
  $scope.$watch('model.account.id', function (accountId) {
    if (!accountId) return;
    $scope.isLoading = false;
    $api.account.getSubEmails({
      accountId: accountId
    }).then(function (json) {
      $scope.model.subEmails = json;
    });
    $api.account.getExternalSessionTokens({
      accountId: accountId
    }).then(function (json) {
      $scope.model.sessionTokens = json;
    });
  });
  $scope.$on('$destroy', function () {});
}]);
angular.module('app.controllers').controller('accountEmailIsEmptyController', ['$scope', function ($scope) {}]);
angular.module('app.controllers').controller('accountNotFoundController', ['$scope', '$state', '$brand', function ($scope, $state, $brand) {
  $scope.model = {
    email: $state.params.email,
    logo: $brand.get().logo.contentUrl
  };
}]);
angular.module('app.controllers').controller('brandNotSupportedController', ['$scope', '$brand', function ($scope, $brand) {
  $scope.model = {
    logo: $brand.get().logo.contentUrl
  };
}]);
angular.module('app.controllers').controller('partialSidebarController', ['$scope', '$auth', function ($scope, $auth) {
  $scope.$auth = $auth;
}]);
angular.module('app.controllers').controller('ticketNotFoundController', ['$scope', function ($scope) {}]);
angular.module('app.controllers').controller('userSignInController', ['$scope', '$brand', '$state', '$auth', '$form', '$zendeskApi', function ($scope, $brand, $state, $auth, $form, $zendeskApi) {
  $scope.model = {
    logo: $brand.getLogo(),
    avatar: null,
    error: null
  };
  $scope.status = null;
  $scope.isBusy = false;
  !$zendeskApi.isEmpty() && $zendeskApi.get('currentUser').then(function (response) {
    $scope.model.login = response.currentUser.email;
    $scope.model.avatar = response.currentUser.avatarUrl;
    $scope.$apply();
  });

  $scope.submit = function (form) {
    $scope.model.error = null;
    $form.submit($scope, form, function () {
      return $auth.signIn($scope.model.login, $scope.model.password).then(function () {
        $state.go('account');
      }, function (json) {
        $scope.model.error = json.error_description;
      }).finally(function () {
        $scope.isBusy = false;
      });
    });
  };
}]);
angular.module('app.controllers').controller('zatClientNotFoundController', ['$scope', function ($scope) {}]);